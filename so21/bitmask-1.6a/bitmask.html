<html lang="en">
<head>
<title>Bitmask Collision Detection Library</title>
</head>
<body>
<h1>Bitmask 1.6a</h1>
<p>
The Bitmask library provides C functions for 2D pixel-perfect
collision detection. In addition to just collision detection the
library can also calculate a point of intersection and the number of
overlapping pixels in an efficient way.
</p>

<p>
The library is not tied to any particular graphics
format, but instead allows arbitrary masks to be built using the
provided functions. Performance and memory requirements of
bitmask-based collision detection is generally excellent, as long as
static masks can be used. For rotated and scaled graphics other
methods may be more suitable. 
</p>

<h2>About</h2>

The Bitmask library was written by Ulf Ekstr&ouml;m 2001-2005. It is
released under the <a href="http://www.gnu.org/licenses/lgpl.html">
LGPL</a> licence. 

<h2>Download</h2>

The latest version of the library can always be downloaded from <a
href="http://www.ifm.liu.se/~ulfek/bitmask/download">
http://www.ifm.liu.se/~ulfek/bitmask/download</a>.

<h2>API</h2>

The library is written in portable C, but can also be directly
included in a C++ project. The relevant content of the header file
<tt>bitmask.h</tt> is described below:

<h3><tt>typedef struct bitmask bitmask_t;</tt></h3>

This is the bitmask data type. It can be built and manipulated with the functions below.

<h3><tt>bitmask_t *bitmask_create(int w, int h);</tt></h3>

Allocate (with <tt>malloc</tt>) a bitmask of width <tt>w</tt> and
height <tt>h</tt>. The memory requirement is roughly (w*h)/8
bytes. The mask is cleared on creation, i.e. all bits are zero. Return
<tt>NULL</tt> on memory allocation error.

<h3><tt>void bitmask_free(bitmask_t *m);</tt></h3>

Free all data allocated for the mask.

<h3><tt>void bitmask_clear(bitmask_t *m);</tt></h3>
Clear the mask, set all bits to zero.

<h3><tt>void bitmask_fill(bitmask_t *m);</tt></h3>
Set all bits in the mask to one.

<h3><tt>int bitmask_getbit(const bitmask_t *m, int x, int y);</tt></h3>
Return the bit at (x,y). No bounds checking is performed. The usual computer graphics
coordinate system is used, with (0,0) as the top left point and the y-axis pointing down.

<h3><tt>void bitmask_setbit(bitmask_t *m, int x, int y);</tt></h3>
Set the bit at (x,y) to one. No bounds checking is performed.

<h3><tt>void bitmask_clearbit(bitmask_t *m, int x, int y);</tt></h3>
Clear the bit at (x,y) to zero. No bounds checking is performed.

<h3><tt>int bitmask_overlap(const bitmask_t *a, const bitmask_t *b, int xoffset, int yoffset);</h3></tt>

Return true if the masks <tt>a</tt> and <tt>b</tt> overlap, when
<tt>b</tt> is having the given offset with respect to mask
<tt>a</tt>. By overlap it is ment that the masks have one or several
set bits in the same places. The offsets can be illustrated as

<pre>
   +----+----------..
   |A   | yoffset   
   |  +-+----------..
   |  |B        
   +--+
   |xoffset      
   :  :  
</pre>


Negative offsets are of course allowed, and <tt>a</tt> and <tt>b</tt> may be the same mask.

<h3><tt>int bitmask_overlap_pos(const bitmask_t *a, const bitmask_t *b, int xoffset, int yoffset, int *x, int *y);</tt></h3>

Similar to <tt>bitmask_overlap()</tt>, but if a collision is detected
the first point of <tt>a</tt> where an overlap is found is stored at
<tt>x</tt> and <tt>y</tt>. If no overlap is found <tt>x</tt> and
<tt>y</tt> are not touched.

<h3><tt>int bitmask_overlap_area(const bitmask_t *a, const bitmask_t *b, int xoffset, int yoffset);</tt></h3>

Similar to <tt>bitmask_overlap()</tt>, but returns exactly the number of overlapping pixels. 

<h3><tt>void bitmask_draw(bitmask_t *a, const bitmask_t *b, int xoffset, int yoffset);</tt></h3>

Draw one mask onto another (bitwise OR). Mask <tt>b</tt> is drawn on
mask <tt>a</tt> at the given offset. This can be used to construct a
large mask from several elements, comparable to blitting of images
with an alpha channel.

<h3><tt>void bitmask_erase(bitmask_t *a, const bitmask_t *b, int xoffset, int yoffset);</tt></h3>

Put zeros in <tt>a</tt> where <tt>b</tt> has ones (with the given
offset). Can be used to make holes in a mask.

<h3><tt>bitmask_t *bitmask_scale(const bitmask_t *m, int w, int h);</tt></h3>

Return a new scaled bitmask of dimension <tt>w</tt>&times;<tt>h</tt>. 
If either <tt>w</tt> or <tt>h</tt> is zero a 1&times;1 clear mask 
is returned. Since this function allocates a new mask it is not
recommended to use in a "real time" situation.

<h2>Performance</h2>

Collision detection is not usually a performance bottleneck in a 2D
game, but the library is quite sensitive to the particular compiler
options used. With GCC 3.3.5 on i686 the flags <tt>-O2 -fomit-frame-pointer
-funroll-loops</tt> were found to give the best performance.

<h2>Tricks and Tips</h2>

<h3>Presorting</h3>

Testing all pairs of masks for collision scales quadratically with the
number of masks, and will be the main bottleneck for a large number of
object (>200). This can be improved by sorting the masks with some
suitable method. Just using the standard C <tt>qsort()</tt> on one of
the coordinates is probably good enough in many cases. Note that the
<tt>bitmask_overlap()</tt> function is already doing bounding-box
tests, so don't add an extra layer of these.

<h3>Calculating a collision normal</h3>

An approximate collision normal can be found by calculating the
gradient of the overlap area through the finite difference

<pre>
int dx = bitmask_overlap_area(a,b,xoff+1,yoff) - 
         bitmask_overlap_area(a,b,xoff-1,yoff);
int dy = bitmask_overlap_area(a,b,xoff,yoff+1) - 
         bitmask_overlap_area(a,b,xoff,yoff-1);
</pre>

The vector (dx,dy) will be a good collision normal (it is probably
hard to do better just from the information in the masks). This works
also for rotations, provided you have different masks for different
angles, with a small enough angular step.

<h2>Portability</h2>

In the header file <tt>bitmask.h</tt> the integer type to hold the bits is defined:

<h3><tt>#define BITW unsigned long int</tt></h3>

<p>
This should be the native unsigned int on the target machine. The
library is specially optimized for 32-bit architectures, but work also
using 64 bit unsigned ints. The default value is usually optimal here.
</p>
<p>
You should also make sure that <tt>INLINE</tt> gets defined properly for
you compiler, since this greatly affects the performance of the bitcount
function.
</p>
<p>
Correctness on a particular platform can be verified with the included
test program (<tt>test.c</tt>), which can also run a small benchmark if
started with the <tt>-b</tt> option.
</p>
The library has been tested on at least the following platforms:

<p>
<lu>
<li>i386 GNU/Linux (gcc, Intel icc)
<li>i386 FreeBSD (gcc)
<li>Win32 (gcc, VC6, VC7)
<li>Sparc Solaris (gcc, Sun cc)
<li>G4 Mac OS X (gcc)
<li>MIPS IRIX 5.3 (unknown compiler)
<li>Amiga (unknown specs)
</lu>
</p>

<h2>Contact</h2>
The author can be reached at uekstrom (AT) gmail.com.

<hr>
<small>Ulf Ekstr&ouml;m, March 2005</small>
</body>
</html>
